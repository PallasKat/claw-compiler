# This file is released under terms of BSD license
# See LICENSE file for more information

function claw_f_print_help()
{
cat <<EOF
usage: $1 <OPTIONS> <INPUTFILE> ...

CLAW Fortran compiler options:

   -o <file>                  : place the output into <file>.
   -I <dir>                   : add the directory dir to the list of directories to be searched for header files.
   -J <dir>                   : specify where to put .mod and .xmod files for compiled modules.
   -D <dir>                   : specify output directory for transformed files
   -t=,--target=<target>      : specify the type of accelerator directive language for code generation.
   --target-list              : list the available type of accelerator directive language supported.
   -d=,--directive=<dir-lang> : specify the type of accelerator directive language for code generation.
   --directive-list           : list the available type of accelerator directive language supported.
   --config=<config_file>     : specify a different configuration for the translator.
   --show-config              : list the current configuration information. If used with --config, list the information from the specific configuration.
   -v,--verbose               : print processing status.
   --version                  : print version.
   -h,--help                  : print usage.
   --show-env                 : show environment variables.
   --no-dep                   : don't generate .mod or .xmod file for dependencies.
   -f,--force                 : force the translation of files without directives.
   --force-pure               : force compiler to exit when transformation applied to PURE subroutine/function.
   --debug                    : save intermediate files in __omni_tmp__.
   --stop-pp                  : save intermediate files and stop after preprocess.
   --stop-dependencies        : save intermediate files and stop after dependencies resolution.
   --stop-frontend            : save intermediate files and stop after frontend.
   --stop-translator          : save intermediate files and stop after translator.

Decompiler options:
   -w <integer>               : Set the number of columns for the output Fortran file (default: 80).
   -l                         : Add preprocessor line directives in the output Fortran file.

Process Options

   --Wp[option] : Add preprocessor option.
   --Wf[option] : Add frontend option.
   --Wx[option] : Add Xcode translator option.
   --Wb[option] : Add backend option.
EOF
}

function claw_f_show_env()
{
  CONF_FILE=$OM_CX2X_DRIVER_CONF_DIR/claw_f.conf
  if [ -f $CONF_FILE ]; then
    for val in `sed '/^[[:space:]]*$/d' ${CONF_FILE} | grep -v '^#' | awk -F= '{print $1}'`
    do
      echo -n ${val}=\"
      eval echo -n \"\$$val\"
      echo \"
    done
  else
    omni_error_exit "$CONF_FILE not exist."
  fi
}

function get_target()
{
  clawfc --show-env | grep TARGET | sed 's/TARGET=//' | sed "s/\"//g"
}

function claw_f_set_parameters()
{
  while [ -n "$1" ]; do
    case "$1" in
      *.f90|*.f|*.F90|*.F)
        f_files+=("$1");;
      *.a)
        archive_files+=("$1");;
      *.o)
        obj_files+=("$1");;
      -o)
        shift; output_file=("$1");;
      -D)
        shift; output_dir=("$1");;
      -J)
        shift;
        module_dir=("${1#-J}")
        if [[ $module_dir == \/* ]]
        then
          module_opt+=("-M${module_dir[0]}")
        else
          current_dir=$(pwd)
          module_opt+=("-M$current_dir/${module_dir[0]}")
        fi
        ;;
      -J?*)
        module_dir=("${1#-J}")
        module_opt+=("-M${module_dir[0]}")
        ;;
      -I)
        shift;
        include_opt+=("-I$1")
        other_args+=("-I$1")
        module_dir=("${1#-I}")
        trans_module_opt+=("-M${module_dir[0]}");;
      -I?*)
        include_opt+=("$1")
        other_args+=("$1")
        module_dir=("${1#-I}")
        trans_module_opt+=("-M${module_dir[0]}");;
      -E)
        ONLY_PP=true;;
      -cpp)
        ENABLE_CPP=true;;
      -v|--verbose)
        VERBOSE=true;;
      --version)
        claw_f_print_version; exit 0;;
      -h|--help)
        claw_f_print_help `basename $0`; exit 0;;
      --show-env)
        claw_f_show_env; exit 0;;
      -f|--force)
        FORCE_TRANSLATION=true;;
      --no-dep)
        RESOLVE_DEPENDENCIES=false;;
      --tmp)
        OUTPUT_TEMPORAL=true;;
      --dry)
        DRY_RUN=true;;
      --debug)
        ENABLE_DEBUG=true;;
      --stop-pp)
        VERBOSE=true; STOP_PP=true;;
      --stop-frontend)
        VERBOSE=true; STOP_FRONTEND=true;;
      --stop-dependencies)
        VERBOSE=true; STOP_DEPENDENCIES=true;;
      --stop-translator)
        VERBOSE=true; STOP_TRANSLATOR=true;;
      --stop-backend)
        VERBOSE=true; STOP_BACKEND=true;;
      --stop-compile)
        VERBOSE=true; STOP_COMPILE=true;;
      --Wp*)
        pp_add_opt+=("${1#--Wp}");;
      --Wf*)
        frontend_add_opt+=("${1#--Wf}");;
      --Wx*)
        xcode_translator_add_opt+=("${1#--Wx}");;
      --Wn*)
        native_add_opt+=("${1#--Wn}");;
      --Wb*)
        backend_add_opt+=("${1#--Wb}");;
      --Wl*)
        linker_add_opt+=("${1#--Wl}");;
      --target-list)
        LIST_TARGET=true;;
      --show-config)
        SHOW_CONFIG=true;;
      -t=*)
        TARGET=true;
        target_opt+=("${1#-t=}");;
      --target=*)
        TARGET=true;
        target_opt+=("${1#--target=}");;
      --directive-list)
        LIST_DIRECTIVE=true;;
      -d=*)
        DIRECTIVE=true;
        directive_opt+=("${1#-d=}");;
      --directive=*)
        DIRECTIVE=true;
        directive_opt+=("${1#--directive=}");;
      --config=*)
        CONFIG=true;
        config_opt+=("${1#--config=}");;
      -w)
        MAX_COLUMN=true;
        shift; max_columns=("$1");;
      -l)
        LINE_DIRECTIVE=true;;
      --dump-cx2x-args)
        DUMP_CX2X_ARGS=true;;
      --force-pure)
        FORCE_PURE=true;;
      *)
        other_args+=("$1");;
    esac
    shift
  done

  # Add the current working directory
  module_opt+=("-M$PWD")

  # Add automatically preprocessor macro for corresponding target
  pp_add_opt+=("-D_CLAW")
  if [ "${directive_opt[0]}" == "openacc" ]
  then
    pp_add_opt+=("-D_OPENACC")
  elif [ "${directive_opt[0]}" == "openmp" ]
  then
    pp_add_opt+=("-D_OPENMP")
  fi

  if test $OUTPUT_TEMPORAL = true -a $DRY_RUN = true; then
    omni_error_exit "cannot use both --tmp and --dry options at the same time."
  fi
}

function claw_f_print_version()
{
  echo "@PROJECT_NAME@ @PROJECT_VERSION@ @CLAWFC_GIT_HASH@ (@CMAKE_Fortran_COMPILER_ID@ Preprocessor) (OMNI Compiler @OMNI_GIT_HASH@)"
}

# Process dependencies file trough the frontend
# $1 must be set to the file to process dependencies
function claw_f_process_dependencies()
{
  # Dependency resolution work as follows:
  # TODO
  # The following variables are used:
  # module_name:       Name of the module as declared in the FORTRAN source code.
  # compiled_mod_file: OMNI Compiler XcodeML/F module file.
  #                    filename: <module_name>.xmod (OMNI Convention)
  # source_mod_file:   FORTRAN source code file containing the module
  #                    declaration.
  #                    filename: <any>.<fortran-extentions>
  # current_src_dir:   Directory in which the current processed file is located

  dependencies=()
  module_regex="^[[:space:]]*(USE|use)[[:space:]]+(, *INTRINSIC *::|, *intrinsic *::)?[[:space:]]*([^,|^ |^!]*)"
  while IFS= read -r line
  do
    if [[ $line =~ $module_regex ]]
    then
      module_name="${BASH_REMATCH[3]}"
      dependencies+=("$module_name")
    fi
  done <$1

  # Get the directory and use it to look in the same for dependencies
  current_src_dir=$(dirname $2)

  # If no dependencies, just abord dependency resolution
  if [[ -z "${dependencies[@]}" ]]
  then
    return
  fi

  for dep in "${dependencies[@]}"
  do
    # Reset the control variables
    compiled_mod_file_found=false
    source_mod_file_found=false


    module_name=${dep// } # Remove all spaces
    module_name=${module_name%% }
    source_mod_file="" # Holder variable for the module file when found

    # FORTRAN file extensions used for the search
    fortran_ext=(".f90" ".F90" ".f" ".F" ".f95" ".f03")

    # Add current dir to potential search paths
    module_search_path=()
    module_search_path+=("$current_src_dir")

    # Add user given search paths (-J option)
    for search_path in "${module_opt[@]}"
    do
      module_search_path+=(${search_path:2})
    done

    # Try to locate the fortran source file
    for directory in ${module_search_path[@]}
    do
      compiled_mod_file="$directory/$module_name.xmod"
      if [[ -f $compiled_mod_file ]]
      then
        compiled_mod_file_found=true
        break
      fi
    done

    # Try to locate the fortran source file
    for directory in ${module_search_path[@]}
    do
      for ext in ${fortran_ext[@]}
      do
        source_mod_file="$directory/$module_name$ext"
        if [[ -f $source_mod_file ]]
        then
          source_mod_file_found=true
          break
        fi
      done
      if [[ $source_mod_file_found == true ]]
      then
        break
      fi
    done

    if [[ $source_mod_file_found == false ]]
    then
      # Could not locate a module file with same name. Try to find module file
      # with regular expression
      for directory in ${module_search_path[@]}
      do
        for ext in ${fortran_ext[@]}
        do
          found_file=($(grep -s -l -i "^ *MODULE *$module_name" $directory/*$ext | grep -v ".*\.claw\..*"))
          if [ ${#found_file[@]} -gt 1 ]
          then
            break
          else
            potential_module_file=${found_file[0]}
            if [ ${#potential_module_file} -gt 0 ]
            then
              source_mod_file=$potential_module_file
              source_mod_file_found=true
              break
            fi
          fi
        done
        if [[ $source_mod_file_found == true ]]
        then
          break
        fi
      done
    fi

    # .xmod file is already present
    if [[ $source_mod_file_found == false ]] && [[ $compiled_mod_file_found == true ]]
    then
      [ $VERBOSE = true ] && echo "Warning: only module file found for $module_name. Might be out-of-date"
      continue
    elif [[ $source_mod_file_found == true ]] && [[ $compiled_mod_file_found == true ]]
    then
      if [[ $compiled_mod_file -nt $source_mod_file ]]
      then
        [ $VERBOSE = true ] && echo "Info: module file for $module_name seems up-to-date"
        continue
      fi
    fi

    # No files found. Cannot go any further
    if [[ $source_mod_file_found == false ]] && [[ $compiled_mod_file_found == false ]]
    then
      echo "Error: cannot locate any source file or module file for module $module_name"
      echo "       try providing source directory in module search path"
      exit 1;
    fi

    ### Preprocess file ###
    FILE=$source_mod_file
    DEP_BASENAME=`basename ${FILE%.*}`
    FILE_NAME=`omni_f_norm_file_name "${FILE}"`     # ./hoge/fuga.F -> hoge_2f_fuga_2f_a
    EXT=${file##*.}
    local FILE_PP=${TEMP_DIR}/"${FILE_NAME}".${EXT}

    if [ $FPP_REDIRECT == true ]
    then
      # When ">" or ">>" is used, please use "omni_exec_echo" and "omni_exec_run" instead of "omni_exec".
      omni_exec_echo $OMNI_FPP_CMD "${include_opt[@]}" "${pp_add_opt[@]}" $OMNI_FPP_OPT "${other_args[@]}" "${FILE}" ">" "${FILE_PP}"
      omni_exec_run  $OMNI_FPP_CMD "${include_opt[@]}" "${pp_add_opt[@]}" $OMNI_FPP_OPT "${other_args[@]}" "${FILE}" > "${FILE_PP}"
    else
      omni_exec_echo $OMNI_FPP_CMD "${include_opt[@]}" "${pp_add_opt[@]}" $OMNI_FPP_OPT "${other_args[@]}" "${FILE}"
      omni_exec_run  $OMNI_FPP_CMD "${include_opt[@]}" "${pp_add_opt[@]}" $OMNI_FPP_OPT "${other_args[@]}" "${FILE}"
      mv "${DEP_BASENAME}.i" "${FILE_PP}"
    fi

    # Recurse to get dependencies in the right order
    claw_f_process_dependencies $FILE_PP $FILE

    # Pass the module in the front-end to get the .xmod file
    omni_exec $OMNI_F2X_CMD "${include_opt[@]}" "${module_opt[@]}" "${frontend_add_opt[@]}" $OMNI_F2X_OPT "${FILE_PP}" > /dev/null

  done
}

# Apply the ignore directive. All lines between `!$claw ignore` and
# `!$claw end ignore` are prefixed with the `!$claw ignore` prefix.
# Parameters:
# $1 : input file path edited in place
function applyIgnore()
{
  # Retrieve the ignore start directives in the file
  local startarray=( $(grep -n "\s*\!\$claw ignore" $1 | cut -f1 -d:) )
  # Retrieve the ignore end directives in the file
  local endarray=( $(grep -n "\s*\!\$claw end ignore" $1 | cut -f1 -d:) )

  # Check that we have the same number of start and end directives
  local startlen=${#startarray[*]}
  local endlen=${#endarray[*]}
  if [ "${#startlen[@]}" -ne "${#endlen[@]}" ]; then
    echo "Missing directives"
    exit 1
  fi

  for (( i=0; i<=$(( $startlen -1 )); i++ ))
  do
    local sedstart=$((${startarray[$i]} + 1)) # Compute the start line
    local sedend=$((${endarray[$i]} - 1))     # Compute the end line

    if [ "$sedstart" -gt "$sedend" ]
    then
      echo "claw-error: inverted start-end in ignore directive. ($sedstart:$sedend)"
      exit 1
    fi

    # Insert directive as prefix of each line in the block
    sed -i.bak -e "$sedstart,$sedend s/^/!\$claw ignore/" $1

    # Hide continuation line in the ignored block. If we keep them, the
    # front-end will merge the lines together.
    sed -i.bak -e "$sedstart,$sedend s/&/__CLAWAMP__/" $1
  done
}

# Revert the lines saved by the ignore directive
# All lines starting with !$claw ignore will be modified. The directive is
# removed and the text after is kept.
# $1 : file path
function revertIgnore()
{
  sed -i.bak -e "s/\!\$claw ignore//" $1
  sed -i.bak -e "s/\!\$claw end ignore//" $1

  # Revert the hidden continuation line.
  sed -i.bak -e "s/__CLAWAMP__/\&/" $1
  rm -f $1.bak
}

# Apply the verbatim directive
# Remove all the !$claw verbatim from lines
function applyVerbatim()
{
  sed -i.bak -e "s/\!\$claw verbatim //" $1
  rm -f $1.bak
}
